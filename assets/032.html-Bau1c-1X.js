import{_ as p,c as e,a as t,o as h}from"./app-DKkA6jZv.js";const d={};function s(n,a){return h(),e("div",null,a[0]||(a[0]=[t('<h1 id="_3-2-虚拟内存管理" tabindex="-1"><a class="header-anchor" href="#_3-2-虚拟内存管理"><span>3.2 虚拟内存管理</span></a></h1><h2 id="_3-2-1-虚拟内存的基本概念" tabindex="-1"><a class="header-anchor" href="#_3-2-1-虚拟内存的基本概念"><span>3.2.1 虚拟内存的基本概念</span></a></h2><p>缺页中断是访存指令引起的，说明要访问的页面不在内存中，进行缺页中断处理并调入所要访问的页后，访存指令显然应该重新执行。</p><h3 id="_4-虚拟内存技术的实现" tabindex="-1"><a class="header-anchor" href="#_4-虚拟内存技术的实现"><span>4.虚拟内存技术的实现</span></a></h3><p>虚拟内存技术是补充内存逻辑空间的技术。</p><p>虚拟内存允许将一个作业分多次调入内存。采用连续分配方式时，会使相当一部分内存空间处于空闲状态，造成资源浪费。虚拟内存只能基于非连续分配技术。</p><p>实现方式</p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul><h2 id="_3-2-2-请求分页管理方式" tabindex="-1"><a class="header-anchor" href="#_3-2-2-请求分页管理方式"><span>3.2.2 请求分页管理方式</span></a></h2><p>页式虚拟存储管理的主要特点是，不要求将作业同时全部装入主存的连续区域，一般只装入 10%～30%。</p><p>分页 + 请求调页 + 页面置换</p><p>未被修改的页直接从文件区读入，被置换时不需要调出。已经被修改的页，被置换时需要调出到交换区，以后从交换区调入。</p><table><thead><tr><th>页号</th><th>物理块号</th><th>状态位</th><th>访问字段</th><th>修改位</th><th>外存地址</th></tr></thead><tbody><tr><td></td><td></td><td>是否在内存中</td><td>记录本页一段时间内被访问次数</td><td>换出时是否需要写回外存</td><td></td></tr></tbody></table><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/地址变换机构.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>CPU 看是否在飞机，飞机没有。不在飞机，在火车上没有。不在火车上，火车没满就上火车。火车满了就拉一个人下来。如果他被修改过，就要他去汽车上。上火车，修改页表，修改快表。</p><h2 id="_3-2-3-页框分配" tabindex="-1"><a class="header-anchor" href="#_3-2-3-页框分配"><span>3.2.3 页框分配</span></a></h2><h3 id="_1-驻留集大小" tabindex="-1"><a class="header-anchor" href="#_1-驻留集大小"><span>1.驻留集大小</span></a></h3><p>给一个进程分配的物理页框的集合就是这个进程的驻留集。</p><p>驻留集：请求分页存储管理中给进程分配的物理块的集合。</p><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p><p>固定分配：驻留集大小不变</p><p>可变分配：驻留集大小可变</p><p>局部置换：发生缺页时，只能选进程自己的物理块进行置换。</p><p>全局置换：可以将操作系统保留的空闲物理块置换出去。</p><h3 id="_2-内存分配策略" tabindex="-1"><a class="header-anchor" href="#_2-内存分配策略"><span>2.内存分配策略</span></a></h3><p>（1）固定分配局部置换</p><p>（2）可变分配全局置换</p><p>灵活</p><p>（3）可变分配局部置换</p><h2 id="_3-2-4-页面置换算法" tabindex="-1"><a class="header-anchor" href="#_3-2-4-页面置换算法"><span>3.2.4 页面置换算法</span></a></h2><p>好的页面置换算法应该有较低的页面更换频率。</p><p>最佳置换算法：淘汰最长时间不再访问的页面，无法实现。</p><p>先进先出页面置换算法：先进内存的先出去。可能出现 Belady 异常。队列型算法可能出现 Belady 异常。</p><p>只有 FIFO 算法才会导致 Belady 异常。</p><p>最近最久未使用置换算法：和最佳置换算法相反。</p><p>时钟置换算法：每帧有访问位（剩余访问次数），首次装入时，访问位置为 1，如果是 1，就变 0，如果是 0 就换出。</p><p>装入后，指针后移一位。顺序淘汰。</p><p>CLOCK 算法选择将最近未使用的页面置换出去，因此又称 NRU 算法。</p><p>改进型 CLOCK 置换算法：增加修改位，如果一个页面换出时，该页面修改了，就要写回磁盘。</p><p>（访问位，修改位）=（0，0）：最近未被访问且未被修改，是最佳淘汰页。</p><p>（访问位，修改位）=（0，1）：最近未被访问，但已被修改，不是很好的淘汰页。</p><p>（访问位，修改位）=（1，0）：最近已被访问，但未被修改，可能再被访问。</p><p>（访问位，修改位）=（1，1）：最近已被访问且已被修改，可能再被访问。</p><p>淘汰策略：</p><ol><li>第一轮找（0，0）</li><li>第二轮找（0，1），并把所有页设为（0，x）</li><li>重复 1，2</li></ol><h2 id="_3-2-5-抖动和工作集" tabindex="-1"><a class="header-anchor" href="#_3-2-5-抖动和工作集"><span>3.2.5 抖动和工作集</span></a></h2><p>抖动：刚换出的页面马上要换入内存，刚换入的页面马上要换出内存</p><p>驻留集：分配给进程的物理块数。</p><p>工作集：在某段时间间隔内，进程实际访问页面的集合。</p><p>驻留集大小大于工作集大小。</p><h2 id="_3-2-6-内存映射文件" tabindex="-1"><a class="header-anchor" href="#_3-2-6-内存映射文件"><span>3.2.6 内存映射文件</span></a></h2><h2 id="_3-2-7-虚拟存储器性能影响因素" tabindex="-1"><a class="header-anchor" href="#_3-2-7-虚拟存储器性能影响因素"><span>3.2.7 虚拟存储器性能影响因素</span></a></h2>',52)]))}const r=p(d,[["render",s]]),o=JSON.parse('{"path":"/os/032.html","title":"3.2 虚拟内存管理","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1720103859000,"contributors":[{"name":"ilovecopy","username":"ilovecopy","email":"1205611509@qq.com","commits":2,"url":"https://github.com/ilovecopy"}],"changelog":[{"hash":"d5db2459b570e661d3d7d99a79f49d17d97f2ddc","time":1720103859000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"},{"hash":"2be1877336d36add6192906de44e87ab5b1df4ec","time":1698592164000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"}]},"filePathRelative":"os/032.md"}');export{r as comp,o as data};
