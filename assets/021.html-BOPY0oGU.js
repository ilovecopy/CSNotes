import{_ as p,c as e,a as s,o as n}from"./app-DKkA6jZv.js";const i={};function h(c,a){return n(),e("div",null,a[0]||(a[0]=[s('<h1 id="_2-1-进程与线程" tabindex="-1"><a class="header-anchor" href="#_2-1-进程与线程"><span>2.1 进程与线程</span></a></h1><h2 id="_2-1-1-进程的概念和特征" tabindex="-1"><a class="header-anchor" href="#_2-1-1-进程的概念和特征"><span>2.1.1 进程的概念和特征</span></a></h2><p>PCB 是进程存在的唯一标志</p><p>创建进程，实质上是创建进程实体中的 PCB，撤销进程，实质上是撤销进程的 PCB。</p><p>进程是进程实体的运行过程，是系统进程资源分配和调度的一个独立单位。</p><p>进程实体由程序段、数据段、PCB 组成。</p><h3 id="_2-进程的特征" tabindex="-1"><a class="header-anchor" href="#_2-进程的特征"><span>2.进程的特征</span></a></h3><p>（4）异步性。由于进程的相互制约，使得进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性。</p><h2 id="_2-1-2-进程的状态与转换" tabindex="-1"><a class="header-anchor" href="#_2-1-2-进程的状态与转换"><span>2.1.2 进程的状态与转换</span></a></h2><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/进程状态转换.drawio.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（1）创建态：申请一个空白 PCB，向 PCB 中填写用于控制和管理进程的信息。</p><p>（2）就绪态：进程获得了除处理机外的一切所需资源，一旦获得处理机便可立即运行。</p><p>（3）运行态：进程正在处理机上运行。单处理机中，每个时刻只有一个进程处于运行态。</p><p>（4）阻塞态（等待态）：进程正在等待某一事件而暂停运行，即使处理机空闲，该进程也不能运行。</p><p>（5）结束态：进程正从系统中消失。</p><p>进程自身决定从运行态到阻塞态。</p><p>当一个进程被唤醒，这个进程就进入了就绪态。</p><h2 id="_2-1-3-进程的组织" tabindex="-1"><a class="header-anchor" href="#_2-1-3-进程的组织"><span>2.1.3 进程的组织</span></a></h2><p>PCB 是进程存在的唯一标志。同时 PCB 常驻内存。</p><h2 id="_2-1-4-进程控制" tabindex="-1"><a class="header-anchor" href="#_2-1-4-进程控制"><span>2.1.4 进程控制</span></a></h2><p>在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不中断。</p><h3 id="_1-进程的创建" tabindex="-1"><a class="header-anchor" href="#_1-进程的创建"><span>1.进程的创建</span></a></h3><p>允许一个进程创建另一个进程，创建者称为父进程，被创建的进程称为子进程。子进程继承父进程所拥有的资源。当子进程被撤销时，应将从父进程那获得的资源归还给父进程。在撤销父进程时，通常也会撤销所有子进程。</p><p>（1）为新进程分配一个唯一的进程表示号，并申请一个空白 PCB。若 PCB 申请失败，则创建失败。</p><p>（2）为进程分配其所需的资源。如果资源不足，处于创建态</p><p>（3）初始化 PCB</p><p>（4）插入就绪队列</p><h3 id="_2-进程的阻塞" tabindex="-1"><a class="header-anchor" href="#_2-进程的阻塞"><span>2.进程的阻塞</span></a></h3><p>（1）找到要被阻塞进程的表示好对应的 PCB</p><p>（2）若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。</p><p>（3）把该 PCB 插入相应时间的等待队列，将其处理机资源调度给其他就绪进程。</p><h3 id="_3-进程的唤醒" tabindex="-1"><a class="header-anchor" href="#_3-进程的唤醒"><span>3.进程的唤醒</span></a></h3><p>（1）在该事件的等待队列中找到相应进程的 PCB</p><p>（2）将其从等待队列中移出，并将其状态转换为就绪态</p><p>（3）把该 PCB 插入就绪队列，等待调度程序调度</p><h3 id="_4-进程的终止" tabindex="-1"><a class="header-anchor" href="#_4-进程的终止"><span>4.进程的终止</span></a></h3><p>（1）根据被终止进程的标识符，检索出该进程的 PCB，从中读出该进程的状态。</p><p>（2）若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配该其他进程。</p><p>（3）若该进程还有子孙进程，则应将所有子孙进程终止。</p><p>（4）将该进程拥有的全部资源，或归还给父进程，或归还给操作系统。</p><p>（5）将该 PCB 从所在队列（链表）中删除。</p><h2 id="_2-1-5-进程的通信" tabindex="-1"><a class="header-anchor" href="#_2-1-5-进程的通信"><span>2.1.5 进程的通信</span></a></h2><p>PV 操作是低级通信方式，高级通信是以高效率传送大量数据的通信方式。</p><p>进程的通信分为同一主机内的通信和不同主机之间进程的通信：</p><p>在同一个主机内，使用进程间通信机制通信（操作系统定义）</p><p>不同主机，通过交换报文通信。</p><h3 id="_1-共享存储" tabindex="-1"><a class="header-anchor" href="#_1-共享存储"><span>1.共享存储</span></a></h3><p>进程之间存在一块可以直接访问的共享空间。</p><h3 id="_2-消息传递" tabindex="-1"><a class="header-anchor" href="#_2-消息传递"><span>2.消息传递</span></a></h3><p>（1）直接通信</p><p>发送进程直接把消息发送给接收进程。</p><p>（2）间接通信</p><p>发送进程把消息发送到某个中间实体，接收进程从中间实体中取得消息。中间实体一般称为信箱。</p><h3 id="_3-管道通信" tabindex="-1"><a class="header-anchor" href="#_3-管道通信"><span>3.管道通信</span></a></h3><p>管道通信是一种用于连接一个读进程和一个写进程的一个共享文件。</p><p>管道通信必须提供：互斥、同步和确定对方存在。</p><p>缓冲区只允许一边写入，一边写出。</p><p>管道中数据一旦被读出，就会彻底消失。</p><p>一个管道允许多个写进程，一个读进程。 <img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/管道.png" alt="" loading="lazy"></p><h2 id="_2-1-6-线程和多线程模型" tabindex="-1"><a class="header-anchor" href="#_2-1-6-线程和多线程模型"><span>2.1.6 线程和多线程模型</span></a></h2><h3 id="_6-线程的实现方式" tabindex="-1"><a class="header-anchor" href="#_6-线程的实现方式"><span>6.线程的实现方式</span></a></h3><p>（1）用户级线程</p><p>优点：线程切换不需要转换到内核空间</p><p>缺点：</p><p>1.一个线程阻塞，该进程内所有线程阻塞</p><p>2.内核每次分配给一个进程仅有的一个 CPU，因此进程中只有一个线程能执行。</p><p>（2）内核级线程</p><p>优点：一个线程阻塞，该进程内所有线程可以运行</p><p>缺点：同一进程中线程切换，开销较大。</p><h3 id="_7-多线程模型" tabindex="-1"><a class="header-anchor" href="#_7-多线程模型"><span>7.多线程模型</span></a></h3><p>如果系统同时支持用户级线程和内核线程</p><p>（1）一对一模型</p><p>操作系统为每个用户线程建立一个线程控制块。</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/一对一.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>(2) 多对一模型</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/多对一.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>缺点：操作系统内核只能感知到一个调度单位存在，当多线程进程中某一个线程被阻塞后，该进程被阻塞。</p><p>(3) 多对多模型</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/多对多.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',79)]))}const t=p(i,[["render",h]]),d=JSON.parse('{"path":"/os/021.html","title":"2.1 进程与线程","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1720103859000,"contributors":[{"name":"ilovecopy","username":"ilovecopy","email":"1205611509@qq.com","commits":2,"url":"https://github.com/ilovecopy"}],"changelog":[{"hash":"d5db2459b570e661d3d7d99a79f49d17d97f2ddc","time":1720103859000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"},{"hash":"2be1877336d36add6192906de44e87ab5b1df4ec","time":1698592164000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"}]},"filePathRelative":"os/021.md"}');export{t as comp,d as data};
