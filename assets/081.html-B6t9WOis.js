import{_ as e,c as s,a as i,o as n}from"./app-DKkA6jZv.js";const h={};function o(c,a){return n(),s("div",null,a[0]||(a[0]=[i('<h1 id="_8-1-事务简介" tabindex="-1"><a class="header-anchor" href="#_8-1-事务简介"><span>8.1 事务简介</span></a></h1><h2 id="事务的定义" tabindex="-1"><a class="header-anchor" href="#事务的定义"><span>事务的定义</span></a></h2><p>需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称为事务。</p><h2 id="为什么要有事务" tabindex="-1"><a class="header-anchor" href="#为什么要有事务"><span>为什么要有事务？</span></a></h2><p>现实世界的业务场景需要映射到数据库世界，而现实世界中的一次状态转换需要满足下面几种特性：</p><h2 id="事务的四大特性" tabindex="-1"><a class="header-anchor" href="#事务的四大特性"><span>事务的四大特性</span></a></h2><p>原子性：事务作为一个整体被执行，其中的操作要么都做，要么都不做。</p><p>一致性：事务执行前后，数据库处于合法的状态。</p><p>隔离性：多个事务并发执行时，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能相互干扰。</p><p>持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p><h2 id="原子性-atomicity" tabindex="-1"><a class="header-anchor" href="#原子性-atomicity"><span>原子性（Atomicity）</span></a></h2><p>拿转账作例子：</p><p>转账只有两种状态：要么转了，要么没转。这种规则叫做原子性。</p><h2 id="隔离性-isolation" tabindex="-1"><a class="header-anchor" href="#隔离性-isolation"><span>隔离性（Isolation）</span></a></h2><p>现实世界中，两种状态转换应该是互不影响的。让一些操作执行完了，再让另一些操作执行。</p><h2 id="一致性-consistency" tabindex="-1"><a class="header-anchor" href="#一致性-consistency"><span>一致性（Consistency）</span></a></h2><p>数据库中的数据符合所有现实世界的约束，比如红绿灯只有三种颜色，房价不能为负的。比如建立主键，唯一索引，外键等。</p><h2 id="持久性-durability" tabindex="-1"><a class="header-anchor" href="#持久性-durability"><span>持久性（Durability）</span></a></h2><p>一个状态转换完成后，这个转换的结果将永久保存。</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/事务状态.drawio.png" alt="事务状态.drawio" tabindex="0" loading="lazy"><figcaption>事务状态.drawio</figcaption></figure><p>可以看到，事务处于“提交的”或者“中止的”时候，事务结束。“中止的”代表数据库数据没有变化，“提交的”说明数据库变动刷新到磁盘了。</p><h2 id="mysql-怎么保证原子性" tabindex="-1"><a class="header-anchor" href="#mysql-怎么保证原子性"><span>MySQL 怎么保证原子性？</span></a></h2><p>undo Log</p><h2 id="什么是脏读" tabindex="-1"><a class="header-anchor" href="#什么是脏读"><span>什么是脏读？</span></a></h2><p>读到了另一个事务未提交的数据。</p><h2 id="什么是不可重复读" tabindex="-1"><a class="header-anchor" href="#什么是不可重复读"><span>什么是不可重复读？</span></a></h2><p>事务 B 读取了两次数据，读其中一次的过程中事务 A 改了数据，导致事务 B 读的两次数据不一样。</p><h2 id="什么是幻读" tabindex="-1"><a class="header-anchor" href="#什么是幻读"><span>什么是幻读？</span></a></h2><p>事务 B 前后两次读同一个范围的数据，事务 B 两次读取的过程中，事务 A 新增了数据，导致事务 B 后一次读取到了前一次查询没有读到的行。</p><h2 id="四种隔离级别" tabindex="-1"><a class="header-anchor" href="#四种隔离级别"><span>四种隔离级别</span></a></h2><ul><li>读未提交</li><li>读提交</li><li>可重复读</li><li>串行化</li></ul>',31)]))}const p=e(h,[["render",o]]),t=JSON.parse('{"path":"/database/081.html","title":"8.1 事务简介","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1733029224000,"contributors":[{"name":"ilovecopy","username":"ilovecopy","email":"1205611509@qq.com","commits":4,"url":"https://github.com/ilovecopy"}],"changelog":[{"hash":"c52511581a91d192d5e74c920812734fcf325392","time":1733029224000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"},{"hash":"0951367e0d815b803f7dcc0a07d29f463df6fbbf","time":1715524248000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"},{"hash":"26fca5d87b4817d65ef662742dc693b8c515bbcf","time":1715522683000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"},{"hash":"2be1877336d36add6192906de44e87ab5b1df4ec","time":1698592164000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"}]},"filePathRelative":"database/081.md"}');export{p as comp,t as data};
