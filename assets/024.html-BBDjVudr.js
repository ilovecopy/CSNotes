import{_ as e,c as s,a as n,o as i}from"./app-DKkA6jZv.js";const h={};function p(o,a){return i(),s("div",null,a[0]||(a[0]=[n('<h1 id="_2-4-死锁" tabindex="-1"><a class="header-anchor" href="#_2-4-死锁"><span>2.4 死锁</span></a></h1><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/死锁.drawio.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_2-4-1-死锁的概念" tabindex="-1"><a class="header-anchor" href="#_2-4-1-死锁的概念"><span>2.4.1 死锁的概念</span></a></h2><p>死锁产生的必要条件：</p><h4 id="_1-互斥" tabindex="-1"><a class="header-anchor" href="#_1-互斥"><span>（1）互斥</span></a></h4><p>某段时间某个资源只能被一个进程所占有。</p><h4 id="_2-不剥夺" tabindex="-1"><a class="header-anchor" href="#_2-不剥夺"><span>（2）不剥夺</span></a></h4><p>进程所获得的资源在未使用完成之前，不能被其他进程强行夺走，只能主动释放。</p><h4 id="_3-请求并保持" tabindex="-1"><a class="header-anchor" href="#_3-请求并保持"><span>（3）请求并保持</span></a></h4><p>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程所占有</p><h4 id="_4-循环等待" tabindex="-1"><a class="header-anchor" href="#_4-循环等待"><span>（4）循环等待</span></a></h4><p>死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。</p><h2 id="_2-4-2-死锁预防-资源动态分配当前" tabindex="-1"><a class="header-anchor" href="#_2-4-2-死锁预防-资源动态分配当前"><span>2.4.2 死锁预防（资源动态分配当前）</span></a></h2><h3 id="_1-破坏互斥条件" tabindex="-1"><a class="header-anchor" href="#_1-破坏互斥条件"><span>1.破坏互斥条件</span></a></h3><p>不可行，SPOOLing 技术</p><h3 id="_2-破坏不剥夺条件" tabindex="-1"><a class="header-anchor" href="#_2-破坏不剥夺条件"><span>2.破坏不剥夺条件</span></a></h3><p>复杂，增加系统开销</p><h3 id="_3-破坏请求并保持条件" tabindex="-1"><a class="header-anchor" href="#_3-破坏请求并保持条件"><span>3.破坏请求并保持条件</span></a></h3><p>采用预先静态分配法，在进程运行之前一次申请玩它所需要的所有资源。</p><h3 id="_4-破坏循环等待条件" tabindex="-1"><a class="header-anchor" href="#_4-破坏循环等待条件"><span>4.破坏循环等待条件</span></a></h3><p>采用<strong>顺序资源分配法</strong>，每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。</p><h2 id="_2-4-3-死锁避免-资源动态分配当中" tabindex="-1"><a class="header-anchor" href="#_2-4-3-死锁避免-资源动态分配当中"><span>2.4.3 死锁避免（资源动态分配当中）</span></a></h2><h3 id="_1-系统安全状态" tabindex="-1"><a class="header-anchor" href="#_1-系统安全状态"><span>1.系统安全状态</span></a></h3><p>存在一种顺序分配完所有资源</p><h3 id="_2-银行家算法" tabindex="-1"><a class="header-anchor" href="#_2-银行家算法"><span>2.银行家算法</span></a></h3><p>Dijkstra 1965 年提出了一种能够避免死锁的调度算法，成为银行家算法。一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度。下图有三个客户小明、小红、小强。每个客户都有一定的贷款额度。因为银行家知道不可能所有客户同时都需要最大贷款额，所以他只保留 10 元来服务客户。这里将客户比作进程，贷款单位比作资源，银行家比作操作系统。</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/银行家算法.drawio.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>用于计算动态资源分配的完全性以避免系统进入死锁状态，不能用于判断系统是否进入死锁。</p><p>虽然银行家算法很有意义但缺乏使用价值，因为很少有进程能够在运行前知道其所需资源的最大值。</p><h2 id="_2-4-4-死锁的检测和解除-检测当前有无产生死锁" tabindex="-1"><a class="header-anchor" href="#_2-4-4-死锁的检测和解除-检测当前有无产生死锁"><span>2.4.4 死锁的检测和解除（检测当前有无产生死锁）</span></a></h2><h3 id="_1-资源分配图" tabindex="-1"><a class="header-anchor" href="#_1-资源分配图"><span>1.资源分配图</span></a></h3><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/资源分配图.png" alt="image.png" style="zoom:25%;"><h3 id="_2-死锁定理" tabindex="-1"><a class="header-anchor" href="#_2-死锁定理"><span>2.死锁定理</span></a></h3><p>如果能满足一个进程，那么可以消除该进程所有的边。</p><p>死锁定理：死锁等价于资源分配图不能完全化简</p><h3 id="_3-死锁解除" tabindex="-1"><a class="header-anchor" href="#_3-死锁解除"><span>3.死锁解除</span></a></h3><p>（1）资源剥夺法</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/资源剥夺法.drawio.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（2）撤销进程法</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/撤销进程法.drawio.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（3）进程回退法</p>',41)]))}const t=e(h,[["render",p]]),r=JSON.parse('{"path":"/os/024.html","title":"2.4 死锁","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1720103859000,"contributors":[{"name":"ilovecopy","username":"ilovecopy","email":"1205611509@qq.com","commits":2,"url":"https://github.com/ilovecopy"}],"changelog":[{"hash":"d5db2459b570e661d3d7d99a79f49d17d97f2ddc","time":1720103859000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"},{"hash":"2be1877336d36add6192906de44e87ab5b1df4ec","time":1698592164000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"}]},"filePathRelative":"os/024.md"}');export{t as comp,r as data};
