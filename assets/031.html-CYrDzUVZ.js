import{_ as p,c as i,a as n,o as t}from"./app-DKkA6jZv.js";const s={};function e(o,a){return t(),i("div",null,a[0]||(a[0]=[n('<h1 id="_3-1-内存管理概念" tabindex="-1"><a class="header-anchor" href="#_3-1-内存管理概念"><span>3.1 内存管理概念</span></a></h1><h2 id="_3-1-1-内存管理的基本原理和要求" tabindex="-1"><a class="header-anchor" href="#_3-1-1-内存管理的基本原理和要求"><span>3.1.1 内存管理的基本原理和要求</span></a></h2><p>主要功能：</p><ul><li>内存空间的分配与回收</li><li>地址转换</li><li>内存空间的扩充</li><li>内存共享</li><li>地址保护</li></ul><h4 id="_1-程序的链接和装入" tabindex="-1"><a class="header-anchor" href="#_1-程序的链接和装入"><span>1.程序的链接和装入</span></a></h4><p>将程序变为可在内存中执行的程序步骤</p><ol><li>编译</li><li>链接（形成完整的逻辑地址）</li><li>装入（形成完整的物理地址）</li></ol><p>链接方式</p><p>（1）静态链接</p><p>（2）装入时动态链接</p><p>模块放入内存再链接。</p><p>（3）运行时动态链接</p><p>用到哪个模块就装入哪个模块</p><p>装入方式</p><p>（1）绝对装入</p><p>产生绝对地址装入</p><p>（2）可重定位装入</p><p>装入时把逻辑地址转换成物理地址，装入后不能改变。起始位置 +100</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/静态重定位.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（3）动态运行时装入</p><p>起始位置+x。装入程序把装入模块装入内存后，不立即把装入模块中的相对地址转换为绝对地址，而是把地址转换推迟到程序要真正执行时才进行。装入内存后所有地址均为相对地址。需要一个重定位寄存器支持。</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/动态重定位.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_4-内存保护" tabindex="-1"><a class="header-anchor" href="#_4-内存保护"><span>4.内存保护</span></a></h4><p>（1）设置一对上、下限寄存器</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/内存保护1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（2）采用重定位寄存器和界地址寄存器</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/内存保护2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>界地址寄存器是最大逻辑地址</p><p>重定位寄存器是最小物理地址</p><p>逻辑地址&lt;界地址寄存器，逻辑地址 + 重定位寄存器=物理地址</p><h2 id="_3-1-3-连续分配管理方式" tabindex="-1"><a class="header-anchor" href="#_3-1-3-连续分配管理方式"><span>3.1.3 连续分配管理方式</span></a></h2><p>用户程序在主存中时连续存放的。</p><h3 id="_1-单一连续分配" tabindex="-1"><a class="header-anchor" href="#_1-单一连续分配"><span>1.单一连续分配</span></a></h3><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/单一连续分配.drawio.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>只有一道程序在用户区。</p><h3 id="_2-固定分区分配" tabindex="-1"><a class="header-anchor" href="#_2-固定分区分配"><span>2.固定分区分配</span></a></h3><p>房子已经盖好了，每个分区装入一道作业。</p><ul><li>分区大小相等</li><li>分区大小不等</li></ul><p>分区大小不等需要分区说明表。</p><h3 id="_3-动态分区分配" tabindex="-1"><a class="header-anchor" href="#_3-动态分区分配"><span>3.动态分区分配</span></a></h3><p>就像在空地里盖房子。</p><p>每个分区大小正适合进程需要。</p><p>每个进程就是一个分区，但是换进换出会产生许多外部碎片。</p><p>有一个空闲分区链。</p><p>首次适应算法：从地址底到高分配。</p><p>邻近适应算法：首次适应算法，但是每次从上次查找结束的位置开始找。</p><p>最佳适应算法：总把最小的分配出去，最容易产生内部碎片。</p><p>最坏适应算法：总把最大的分配出去。</p><h2 id="_3-1-4-基本分页存储管理" tabindex="-1"><a class="header-anchor" href="#_3-1-4-基本分页存储管理"><span>3.1.4 基本分页存储管理</span></a></h2><p>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。按块申请空间，这个块比固定分区分配的分区要小很多，平均每个页产生半个块的页内碎片。</p><p>多个进程并发执行时，所有进程的页表大多数驻留在内存中，在系统中只设置一个页表寄存器。平时进程未执行时，页表的始址和页表长度存放在本进程的 PCB 中，当调度到某个进程时，才将这两个数据装入页表寄存器中。每个进程都有一个单独的逻辑地址，有一张属于自己的页表。</p><h3 id="_1-分页存储的几个概念" tabindex="-1"><a class="header-anchor" href="#_1-分页存储的几个概念"><span>1.分页存储的几个概念</span></a></h3><p>（1）页面和页面大小</p><p>进程中的块称为页或页面，内存中的块称为页框或页帧。外存中的块称为块或盘块。</p><table><thead><tr><th></th><th>进程</th><th>内存</th><th>外存</th></tr></thead><tbody><tr><td>块</td><td>页、页面</td><td>页框、页帧</td><td>块、盘块</td></tr></tbody></table><p>（3）页表</p><p>为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，它记录页面在内存中对应的物理块号，页表一般存放在内存中。页表的功能由一组专门的存储器实现，其始址放在页表基址寄存器（PTBR）中。这样才能满足在地址转换时能够较快地完成逻辑地址和物理地址之间的转换。</p><p>每个进程的地址空间、页目录和 PDBR 的内容存在一一对应的关系。</p><p>页表=（页号，块号），因为页号是连续存放的，所以不占字节，块号由映射到的物理空间大小决定</p><div class="hint-container tip"><p class="hint-container-title">如何确立页表项的大小？（32 位逻辑地址、字节编址单位、一页 4KB）</p><p>地址空间一共有$2^{32}B/4KB=1M$页，需要$\\log_{2} 1M=20$位容纳所有页面，所以页表项大小&gt;=3B。</p></div><p>页表项位数 + 每页位数&gt;逻辑地址空间位数</p><p>物理地址位数&gt;逻辑地址位数</p><p>怎样把逻辑地址变成物理地址？</p><div class="hint-container tip"><p class="hint-container-title">已知页面大小 L=1KB，页号 2 对应的物理块为 8，计算逻辑地址 A=2500 的物理地址 E？</p><p>页面大小 1KB，说明页内偏移量为 10 位，因为 $1KB=2^{10}B$ 页号=2500/1K=2, 页内偏移=2500%1K=452, 已知页号 2 对应物理块号 8，所以物理地址为 8x1K+452=8644</p></div><div class="hint-container tip"><p class="hint-container-title">某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为$2^{10}B$，页表项大小为 2B，逻辑地址结构为（页目录号，页号，页内偏移量）。逻辑地址空间大小为$2^{16}$页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是？</p><p>一页可以放$2^{9}$个页表项，需要$2^{16}$个页表项所以需要$2^{7}$个页面。</p></div><p>页大小$2^n$B表示页内偏移量 n 位</p><p>页号 n 位表示逻辑空间地址大小$2^n$页</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/页表.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>分页存储地址变换机构 以上过程 2 次访存，1 是取块号，2 是根据物理地址取指令。</p><p>进程切换时，PDBR 的内容会变化。同一进程的线程切换时，PDBR 的内容不会变化。每个进程的地址空间、页目录和 PDBR 的内容存在一一对应的关系。</p><h3 id="_2-基本地址变换机构" tabindex="-1"><a class="header-anchor" href="#_2-基本地址变换机构"><span>2. 基本地址变换机构</span></a></h3><p>基本地址变换机构利用页表将逻辑地址转换为内存中的物理地址。</p><p>1.逻辑地址 A 可以用（页号，页内偏移量）表示，页号 x 页表项长度 + 页内偏移量=逻辑地址 A</p><p>2.用页号找到页表里的块号。块号的地址（页表项地址）=页表始址 + 页号 Px 页面大小 L</p><p>3.物理地址=块号 x 页面大小 L+ 页内偏移量</p><h3 id="_3-具有快表的地址变换机构" tabindex="-1"><a class="header-anchor" href="#_3-具有快表的地址变换机构"><span>3.具有快表的地址变换机构</span></a></h3><p>加入快表，快表是高速缓冲存储器，如果通过快表查询块号则减少了一次访存。以下可能需要 2 次访存或 1 次访存。 <img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/快表.png" alt="" loading="lazy"></p><p>添加快表的分页存储地址变换机构。</p><p>查找成功，一次访存。</p><p>查找失败，两次访存。</p><p>查快表不算访存。</p><p>TLB 是页表的副本。</p><h3 id="_4-两级页表" tabindex="-1"><a class="header-anchor" href="#_4-两级页表"><span>4.两级页表</span></a></h3><p>为什么要用两级页表？因为连续存放页表需要大块内存空间。可以减少页表所占的连续内存空间。</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/二级页表.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_3-1-5-基本分段存储管理" tabindex="-1"><a class="header-anchor" href="#_3-1-5-基本分段存储管理"><span>3.1.5 基本分段存储管理</span></a></h2><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/分段.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>分段系统的地址变换过程 2 次访存。</p><h2 id="_3-1-6-段页式管理" tabindex="-1"><a class="header-anchor" href="#_3-1-6-段页式管理"><span>3.1.6 段页式管理</span></a></h2><p>逻辑地址用段号去换了个页号地址，拿着页号地址换了个块号。变成了物理地址。 <img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/段页式.png" alt="" loading="lazy"></p><p>段页式系统的地址变换机构</p><p>段页式存储管理用分段的方法来分配和管理用户地址空间，用分页的方法来管理物理存储空间。</p><p>一共 3 次访存</p><div class="hint-container tip"><p class="hint-container-title">怎样加快虚实地址转换？</p><p>增大快表容量能把更多的表项装入快表中，会加快虚实地址转换的平均速率。</p><p>让页表常驻内存可以省去一些不在内存中的页表从磁盘上调入的过程。</p></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>对主存的访问是以字节或字为单位的，主存的分配是以块（即页）或段为单位。</p></div><p>段页式管理的地址空间是二维的，因为程序员在标识一个地址时，既需要给出段名，又要给出段内地址。确定一个地址需要几个参数，作业地址空间就是几维的。</p>',96)]))}const h=p(s,[["render",e]]),l=JSON.parse('{"path":"/os/031.html","title":"3.1 内存管理概念","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1720103859000,"contributors":[{"name":"ilovecopy","username":"ilovecopy","email":"1205611509@qq.com","commits":3,"url":"https://github.com/ilovecopy"}],"changelog":[{"hash":"d5db2459b570e661d3d7d99a79f49d17d97f2ddc","time":1720103859000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"},{"hash":"87edf6c08c4a79890356eb85f53da45fb5c46d12","time":1698675745000,"email":"1205611509@qq.com","author":"ilovecopy","message":"fix format"},{"hash":"2be1877336d36add6192906de44e87ab5b1df4ec","time":1698592164000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"}]},"filePathRelative":"os/031.md"}');export{h as comp,l as data};
