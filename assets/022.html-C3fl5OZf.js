import{_ as e,c as t,a as o,o as s}from"./app-DKkA6jZv.js";const c={};function d(n,a){return s(),t("div",null,a[0]||(a[0]=[o('<h1 id="_2-2-数据库范式" tabindex="-1"><a class="header-anchor" href="#_2-2-数据库范式"><span>2.2 数据库范式</span></a></h1><h2 id="第一范式-1nf" tabindex="-1"><a class="header-anchor" href="#第一范式-1nf"><span>第一范式 1NF</span></a></h2><p>确保数据库字段的原子性。</p><p>例如，假设有一个员工信息表，如果将员工的姓名、地址和电话号码存储在同一列中，则这个表不符合第一范式。正确的做法是，将员工的姓名、地址和电话号码分别存储在三个单独的列中，以确保数据的单一性。</p><h2 id="第二范式-2nf" tabindex="-1"><a class="header-anchor" href="#第二范式-2nf"><span>第二范式 2NF</span></a></h2><p>换句话说，如果数据库表是符合第二范式的，那么它的每一行都必须仅通过主键字段来标识。这确保了数据的独立性和可维护性，避免了错误的数据冗余。</p><p>例如，假设有一个员工信息表，如果在表中存储了员工的编号，姓名和所属部门名称，则这个表不符合第二范式。正确的做法是，将员工的编号、姓名和部门编号分别存储在三个不同的表中，以确保数据的独立性。</p><h2 id="第三范式-3nf" tabindex="-1"><a class="header-anchor" href="#第三范式-3nf"><span>第三范式 3NF</span></a></h2>',8)]))}const i=e(c,[["render",d]]),r=JSON.parse('{"path":"/database/022.html","title":"2.2 数据库范式","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1715524248000,"contributors":[{"name":"ilovecopy","username":"ilovecopy","email":"1205611509@qq.com","commits":3,"url":"https://github.com/ilovecopy"}],"changelog":[{"hash":"0951367e0d815b803f7dcc0a07d29f463df6fbbf","time":1715524248000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"},{"hash":"26fca5d87b4817d65ef662742dc693b8c515bbcf","time":1715522683000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"},{"hash":"2be1877336d36add6192906de44e87ab5b1df4ec","time":1698592164000,"email":"1205611509@qq.com","author":"ilovecopy","message":"add"}]},"filePathRelative":"database/022.md"}');export{i as comp,r as data};
