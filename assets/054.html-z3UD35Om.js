import{_ as a,c as s,a as n,o as i}from"./app-DKkA6jZv.js";const t={};function c(p,e){return i(),s("div",null,e[0]||(e[0]=[n(`<h1 id="_5-4-索引失效" tabindex="-1"><a class="header-anchor" href="#_5-4-索引失效"><span>5.4 索引失效</span></a></h1><h2 id="隐式转换" tabindex="-1"><a class="header-anchor" href="#隐式转换"><span>隐式转换</span></a></h2><p>什么是隐式转换？</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/image-20250528204529485.png" alt="image-20250528204529485" tabindex="0" loading="lazy"><figcaption>image-20250528204529485</figcaption></figure><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/image-20250528204624873.png" alt="image-20250528204624873" tabindex="0" loading="lazy"><figcaption>image-20250528204624873</figcaption></figure><p>运行 select &#39;10&#39;&gt;9;返回 1</p><p>运行 select &#39;10&#39;&gt;&#39;9&#39;;返回 0</p><p>这就是隐式转换规则，对于不同类型的值比较，会把字符串转换为数字</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">create table db.test(</span>
<span class="line">id BIGINT auto_increment PRIMARY key,</span>
<span class="line">name varchar(30),</span>
<span class="line">create_time TIMESTAMP(6),</span>
<span class="line">update_time TIMESTAMP(6) on UPDATE CURRENT_TIMESTAMP(6)</span>
<span class="line">);</span>
<span class="line">create index idx_name on db.test(name);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"></div></div><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/image-20250528215731506.png" alt="image-20250528215731506" tabindex="0" loading="lazy"><figcaption>image-20250528215731506</figcaption></figure><p>select * from test where name = 1 不走索引</p><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/image-20250528215818353.png" alt="image-20250528215818353" tabindex="0" loading="lazy"><figcaption>image-20250528215818353</figcaption></figure><p>select * from test where name = &#39;1&#39; 走索引</p><p>等价于 select * from test where name = cast(&#39;1&#39; as signed int);</p><p>这是因为 mysql 在遇到字符串和数字比较时，会把字符串转换为数字。</p><p>select * from test where name = 1; 等价于 select * from test where cast(name as signed int)=1;</p><h2 id="对索引使用函数" tabindex="-1"><a class="header-anchor" href="#对索引使用函数"><span>对索引使用函数</span></a></h2><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/image-20250528230857671.png" alt="image-20250528230857671" tabindex="0" loading="lazy"><figcaption>image-20250528230857671</figcaption></figure><p>select * from test where length(name)=2;</p><p>对索引使用函数不走索引。</p><p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值。</p><h2 id="where-子句中的-or" tabindex="-1"><a class="header-anchor" href="#where-子句中的-or"><span>WHERE 子句中的 OR</span></a></h2><figure><img src="https://csnotes.oss-cn-beijing.aliyuncs.com/photos/image-20250528234532318.png" alt="image-20250528234532318" tabindex="0" loading="lazy"><figcaption>image-20250528234532318</figcaption></figure><p>因为 OR 的含义是两个条件满足一个即可，所以只有一个条件列是索引列是没意义的</p>`,24)]))}const g=a(t,[["render",c]]),r=JSON.parse('{"path":"/database/054.html","title":"5.4 索引失效","lang":"zh-CN","frontmatter":{},"git":{},"filePathRelative":"database/054.md"}');export{g as comp,r as data};
